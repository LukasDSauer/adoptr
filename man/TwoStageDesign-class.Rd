% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TwoStageDesign.R
\docType{class}
\name{TwoStageDesign-class}
\alias{TwoStageDesign-class}
\alias{TwoStageDesign}
\alias{TwoStageDesign,numeric-method}
\alias{tunable_parameters}
\alias{tunable_parameters,TwoStageDesign-method}
\alias{make_tunable}
\alias{make_tunable,TwoStageDesign-method}
\alias{make_fixed}
\alias{make_fixed,TwoStageDesign-method}
\alias{update,TwoStageDesign-method}
\alias{n2}
\alias{n2,TwoStageDesign,numeric-method}
\alias{n}
\alias{n,TwoStageDesign,numeric-method}
\alias{c2}
\alias{c2,TwoStageDesign,numeric-method}
\alias{scaled_integration_pivots}
\alias{scaled_integration_pivots,TwoStageDesign-method}
\alias{plot,TwoStageDesign-method}
\alias{simulate,TwoStageDesign,numeric-method}
\title{Two-stage designs}
\usage{
TwoStageDesign(...)

\S4method{TwoStageDesign}{numeric}(n1, c1f, c1e, n2_pivots, c2_pivots,
  x1_norm_pivots, weights)

tunable_parameters(x, ...)

\S4method{tunable_parameters}{TwoStageDesign}(x, ...)

make_tunable(x, ...)

\S4method{make_tunable}{TwoStageDesign}(x, ...)

make_fixed(x, ...)

\S4method{make_fixed}{TwoStageDesign}(x, ...)

\S4method{update}{TwoStageDesign}(object, params, ...)

n2(d, x1, ...)

\S4method{n2}{TwoStageDesign,numeric}(d, x1, ...)

n(d, x1, ...)

\S4method{n}{TwoStageDesign,numeric}(d, x1, ...)

c2(d, x1, ...)

\S4method{c2}{TwoStageDesign,numeric}(d, x1, ...)

scaled_integration_pivots(d, ...)

\S4method{scaled_integration_pivots}{TwoStageDesign}(d, ...)

\S4method{plot}{TwoStageDesign}(x, y = NULL, rounded = T, ...,
  k = 100)

\S4method{simulate}{TwoStageDesign,numeric}(object, nsim, dist, theta,
  seed = NULL, ...)
}
\arguments{
\item{...}{optional arguments depending on implementation}

\item{n1}{cf. slot}

\item{c1f}{cf. slot}

\item{c1e}{cf. slot}

\item{n2_pivots}{cf. slot}

\item{c2_pivots}{cf. slot}

\item{x1_norm_pivots}{cf. slot}

\item{weights}{cf. slot}

\item{x}{design}

\item{object}{object to update}

\item{params}{vector of design parameters (must be in same order as returned
by \code{as.numeric(design)})}

\item{d}{design object}

\item{x1}{stage-one outcome}

\item{y}{not used}

\item{rounded}{should n-values be rounded?}

\item{k}{number of points to use for plotting}

\item{nsim}{number of simulation runs}

\item{dist}{data distribution}

\item{theta}{location parameter of the data distribution}

\item{seed}{random seed}
}
\description{
[ToDo]

[TODO]
}
\section{Methods (by generic)}{
\itemize{
\item \code{n}: overall sample size given stage-one outcome

\item \code{scaled_integration_pivots}: get the actual pivots points (knots) of the numerical integration routine
rule.

\item \code{simulate}: simulate from the given design under parameter theta.
}}

\section{Slots}{

\describe{
\item{\code{n1}}{stage-one sample size}

\item{\code{c1f}}{early stopping for futility boundary}

\item{\code{c1e}}{early stopping for efficacy boundary}

\item{\code{n2_pivots}}{vector of length order giving the values of n2 at the
pivot points of the numeric integration rule [TODO: these are not available during construction]}

\item{\code{c2_pivots}}{vector of length order giving the values of c2 at the
pivot points of the numeric integration rule [TODO: these are not available during construction]}

\item{\code{x1_norm_pivots}}{normalized pivots for integration rule (in [-1, 1])}

\item{\code{weights}}{weights of conditional score values at x1_norm_pivots for
approximating the integral over x1.}

\item{\code{tunable}}{named logical vector indicating whether corresponding slot is considered a tunable parameter}

\item{\code{rounded}}{logical that indicates whether rounded n-values should be used}
}}

