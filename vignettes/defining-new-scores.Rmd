---
title: "Defining new scores"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Defining new scores}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width  = 7,
  fig.height = 5
)
```

```{r setup}
library(adoptr)
```



In addition to the already existing ones, `adoptr` allows the user to
define his own scores. 
This requires a basic knowledge on object oriented programming in R.
While all unconditional scores are based on conditional scores via
`expected()` (c.f. vignette on score arithmetic), 
conditional scores have to be defined by building three blocks.

- the class of the score as a subclass of `ConditionalScore`

- a constructor method

- a method `evaluate()` to evaluate the score on a design

In this example we illustrate how one can implement the probability of 
continuation. 
Under the null hypothesis $\delta = 0$ it is given via
$$
P[\text{continue}] = P[c_f \leq X_1 \leq c_e] =\Phi(c_e) - \Phi(c_f),
$$
where $\Phi$ denotes the cumulative distribution function of the standard
normal distribution.

Note that as all unconditional scores
this score needs to be represented by a conditional score.
One can express it via
$$
\Phi(c_e) - \Phi(c_f) = \int_{c_f}^{c_e} \phi(x) dx =
\int_{-\infty}^{\infty} 1_{x \in [c_f, c_e]} \phi(x) dx.
$$

Therefore, the conditional score $f(x) = 1_{x \in [c_f, c_e]}$ has to be defined.
To do so, a new class and a corresponding method `evaluate()` have to be 
defined. Let us call the class `ConditionalContinuation`.
Then it can be implemented as follows.

```{r define-new-score}
# Define the class
setClass("ConditionalContinuation", contains = "ConditionalScore")

# Define constructor
ConditionalContinuation <- function(dist, prior) new("ConditionalContinuation", 
                                                     distribution = dist, prior = prior)

# Define corresponding evaluate method
setMethod("evaluate", signature("ConditionalContinuation", "TwoStageDesign"),
          function(s, design, x1, optimization = FALSE, ...) {
              res <- 0
              if(design@c1f <= x1 && x1 <= design@c1e)
                  res <- 1
              return(res)
})

```

Note that the option `optimization` has to be given in order to apply
a faster Gaussian quadrature if the scores are used during optimization.
It suffices to include it as above and can be ignored by the user.

Now we can define the `IntegralScore` representing the probability to 
continue under the effect size $\delta = 0$.

```{r p-cont}
p_cont <- expected(ConditionalContinuation(Normal(), PointMassPrior(.0, 1)))
```

Let us check if it can be evaluated.
We need a dummy design to do so.

```{r define-design}
design <- TwoStageDesign(
    n1  = 100,
    c1f = .0,
    c1e = 2.0,
    n2_pivots = rep(150, 5),
    c2_pivots = seq(2.0, 0.0, length.out = 5)
)
```


```{r evaluate-p-cont}
evaluate(p_cont, design)
```
Evaluating directly from the design yields.

```{r check}
pnorm(design@c1e) - pnorm(design@c1f)
```

The values are identical what shows that the definition of the new score
was successful.
