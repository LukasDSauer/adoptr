---
title: "Sample workflow"
author: "Kevin Kunzmann"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(otsd)
```

some initial design

```{r}
n1     <- 20
c1f    <-   .0
c1e    <-  2.5
k      <-  5
n2_piv <- rep(30.0, k)
c2_piv <- rep( 2.0, k)

design <- BSDesign(
  n1 = n1, 
  early_stopping_for_futility = c1f, 
  early_stopping_for_efficacy = c1e, 
  weights_n2 = n2_piv,
  weights_c2 = c2_piv,
  n_knots    = 5L
)

z1 <- seq(-2, 4, .01)
plot(z1, n2(design, z1), 'l')
plot(z1, c2(design, z1), 'l')
```


```{r}
# define null and alternative as point mass distributions
null        <- PointMassDistribution(.0, 1)
alternative <- PointMassDistribution(.4, 1)
```

'SampleSize' is a conditional score returning, well, the sample size ;)
```{r}
ss <- SampleSize(alternative)
plot(z1, eval(ss, design, z1))
```

We can 'integrate' any conditional score to eliminate the dependency on Z1
(internally done via adaptive gauss quad).

```{r}
ess <- integrate(SampleSize(alternative))
eval(ess, design)
```

Same thing works for (conditional) power

```{r}
cp  <- ConditionalPower(alternative)
plot(z1, eval(cp, design, z1))
pow <- integrate(cp)
eval(pow, design)
```

type one error rate works the same

```{r}
toer <- integrate(ConditionalPower(null))
eval(toer, design)
```

[ToDo: extend to continuous priors]



# Define objective

```{r}
objective <- function(x) {
  d  <- update(design, x) # identity = update(d, as.numeric(d)) 
  plot(z1, n2(d, z1) + n1(d), 'l', ylim = c(0, 75))
  points(get_knots(d), n2(d, get_knots(d)) + n1(d))
  return(
    eval(ess, d) + 
      .01 * abs(diff(n2(d, get_knots(d)))) + 
      .01 * diff(n2(d, get_knots(d)))^2 +
      abs(diff(c2(d, get_knots(d)))) + 
      diff(c2(d, get_knots(d)))^2
  )
}
objective(as.numeric(design))

constraint <- function(x) {
  d  <- update(design, x)
  c(
    .8 - eval(pow, d),
    eval(toer, d) - 0.05
  )
}
constraint(as.numeric(design))

ub <- c(
  40,
  1,
  3.5,
  numeric(k) + 50,
  numeric(k) + 5
)

lb <- c(
  10,
  -1,
  1.25,
  numeric(k) + 5,
  numeric(k) - 5
)

res <- nloptr::nloptr(
  as.numeric(design),
  lb = lb,
  ub = ub,
  eval_f      = objective,
  eval_g_ineq = constraint,
  opts = list(
    algorithm   = "NLOPT_LN_COBYLA",
    xtol_rel    = 1e-4,
    maxeval     = 250,
    print_level = 2
  )
)

d2 <- update(design, res$solution)
d2
plot(z1, n2(d2, z1) + n1(design), 'l')
plot(z1, c2(d2, z1), 'l')
```
