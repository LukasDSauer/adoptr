---
title: "OTSD quickstart"
author: "Kevin Kunzmann"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quickstart}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.width = 8
)
library(otsd)
```

Create some more or less random start design.

```{r create-design}
order <- 7

design <- GQDesign(
  n1 = 25, 
  c1f = 0,
  c1e = 2,
  n2_pivots = rep(40.0, order), 
  c2_pivots = rep( 1.96, order), 
  order = order)
#TODO we need nice output for out designs...
```

```{r plot-design}
z1 <- seq(-2, 4, .01)
par(mfrow = c(1, 2))
plot(z1, n(design, z1), 'l', ylim = c(0, max(n(design, z1))))
plot(z1, c2(design, z1), 'l')
```



# Define scores 

```{r define-statistical-model}
# define null and alternative as point mass distributions
null        <- PointMassPrior(.0, 1)
alternative <- PointMassPrior(.4, 1)
dist        <- Normal()# data distribution
```

```{r define-scores}
ess  <- integrate(ConditionalSampleSize(dist, alternative))
cp   <- ConditionalPower(dist, alternative)
pow  <- integrate(cp)
toer <- integrate(ConditionalPower(dist, null))
smth <- Smoothness_n2()

# print TODO: need nice functionality like summary(design, ess, pow, toer)
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, design))
))
```

```{r define-constraints}
# currently just checking whether it is evaluable
evaluate(
  subject_to(
    pow >= .8,
    toer <= .05
  ),
  design
)
# goal would be something like
#
# minimize(
#   ess + .001 * smth,
#   subject_to(
#     pow >= .8,
#     toer <= .05
#   )
# )
```


# Define objective

```{r}
objective <- function(x) {
  d  <- update(design, x)
  evaluate(ess, d) + .001*evaluate(smth, d)
}
objective(tunable_parameters(design))
constraint <- function(x) {
  d  <- update(design, x)
  c(
    .8 - evaluate(pow, d),
    evaluate(toer, d) - 0.05,
    x[2] - x[3] + .1,
    diff(c2(d, scaled_integration_pivots(d)))
  )
}
constraint(tunable_parameters(design))
ub <- c(50, 1, 4, numeric(order) + 50, numeric(order) + 5)
lb <- c(10, -1, 1, numeric(order) + 2, numeric(order) - 5)
res <- nloptr::nloptr(
  tunable_parameters(design),
  lb = lb,
  ub = ub,
  eval_f      = objective,
  eval_g_ineq = constraint,
  opts = list(
    algorithm   = "NLOPT_LN_COBYLA",
    xtol_rel    = 1e-4,
    maxeval     = 2500
  )
)
d2 <- update(design, res$solution)
par(mfrow = c(1, 2))
plot(z1, n(d2, z1), 'l', ylim = c(0, max(n(d2, z1))))
plot(z1, c2(d2, z1), 'l')
```

Compute the scores using fast internal representation (Gauss quadrature).

```{r}
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, d2, specific = TRUE))
))
```

Compute the scores using adaptive quadrature rules (increased precision but slow).

```{r}
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, d2, specific = FALSE))
))
```
