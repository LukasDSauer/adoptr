---
title: "OTSD quickstart"
author: "Kevin Kunzmann"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quickstart}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.width = 8
)
library(otsd)
```

Create some more or less random start design.

```{r create-design}
order <- 7

design <- GQDesign(
  n1 = 25, 
  c1f = 0,
  c1e = 2,
  n2_pivots = rep(40.0, order), 
  c2_pivots = rep( 1.96, order), 
  order = order)
#TODO we need nice output for out designs...
```

```{r plot-design}
z1 <- seq(-2, 4, .01)
plot(design)
```



# Define scores 

```{r define-statistical-model}
# define null and alternative as point mass distributions
null        <- PointMassPrior(.0, 1)
alternative <- PointMassPrior(.4, 1)
dist        <- Normal()# data distribution
```

```{r define-scores}
ess  <- integrate(ConditionalSampleSize(dist, alternative))
cp   <- ConditionalPower(dist, alternative)
pow  <- integrate(cp)
toer <- integrate(ConditionalPower(dist, null))
smth <- Smoothness_n2()

# print TODO: need nice functionality like summary(design, ess, pow, toer)
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, design))
))
```


# Optimize

```{r}
minimize(
  ess + 0.001*smth,
  subject_to(
    pow  >= 0.8,
    toer <= .05
  ),
  initial_design = design,
  lower_boundary_design = update(design, c(10, -1, 1, numeric(order) + 2, numeric(order) - 5)),
  upper_boundary_design = update(design, c(50, 1, 4, numeric(order) + 50, numeric(order) + 5))
) ->
  optimal_design

plot(optimal_design, "Conditional power" = cp)
```

Compute the scores using fast internal representation (Gauss quadrature).

```{r}
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, optimal_design, specific = TRUE))
))
```

Compute the scores using adaptive quadrature rules (increased precision but slow).

```{r}
do.call(sprintf, c(
  list("ESS: %.1f, power: %.3f, maximal type one error rate: %.3f"), 
  lapply(list(ess, pow, toer), function(s) evaluate(s, optimal_design, specific = FALSE))
))
```
